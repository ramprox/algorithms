package ru.ramprox.algorithms.sorting;

import java.util.Comparator;

public class GenericAlgorithms {

    // Инварианты - условия, которые остаются неизменными в ходе выполнения алгоритма


    // --------------------------  Пузырьковая сортировка  --------------------------

    // При первом проходе правый последний элемент будет самым большим элементом
    // При втором проходе правый предпоследний элемент будет меньше чем правый крайний элемент
    // Отсортированные элементы собираются справа
    // В ходе работы самый большой элемент, словно пузырек, всплывает до конца массива

    // Инвариант - элементы данных справа от outer отсортированы. При первом проходе отсортированные элементы
    // отсутствуют, а справа от outer нет ни одного элемента, т.к. счетчик инициализируется позицией крайнего
    // правого элемента

    // Количество сравнений - N x (N - 1) / 2
    // Количество перестановок - 0 ... N x (N - 1) / 2
    // Сложность - O(N^2)
    public static <T> void bubbleSort(T[] array, Comparator<T> comparator) {
        for (int outer = array.length - 1; outer > 1; outer--) {
            for (int inner = 0; inner < outer; inner++) {
                if (comparator.compare(array[inner], array[inner + 1]) > 0) {
                    T temp = array[inner];
                    array[inner] = array[inner + 1];
                    array[inner + 1] = temp;
                }
            }
        }
    }

    // -------------------------------  Сортировка методом выбора  --------------------------------------------

    // Первый проход - последовательно перебираются все элементы и выбирается самый маленький. Самый маленький элемент
    // меняется местами с тем, который стоит в крайней левой позиции (0).
    // Следующий проход начинается с позиции 1, а обнаруженный минимальный элемент меняется местами с элементом в позиции 1.
    // Отсортированные элементы собираются слева

    // Инвариант - элементы данных с индексами, меньшими либо равными outer, всегда отсортированы

    // Количество сравнений - N x (N - 1) / 2
    // Количество перестановок - 0 ... N - 1

    // Для больших значений N время сравнения является определяющим фактором, поэтому можно сказать, что эта сортировка
    // выполняется за время O(N^2). Эта сортировка выполняется быстрее пузырьковой из-за меньшего количества
    // перестановок
    // Сложность - O(N^2)
    public static <T> void selectionSort(T[] array, Comparator<T> comparator) {
        for(int outer = 0; outer < array.length - 1; outer++) {
            int minIndex = outer;
            for(int inner = outer + 1; inner < array.length; inner++) {
                if(comparator.compare(array[inner], array[minIndex]) < 0) {
                    minIndex = inner;
                }
            }
            T temp = array[outer];
            array[outer] = array[minIndex];
            array[minIndex] = temp;
        }
    }

    // -----------------------------  Сортировка методом вставки  -------------------------------------------

    // При первом проходе маркер ставится на элемент с позицией 1 (второй элемент в массиве).
    // Индекс и сам элемент запоминаются. Элементы находящиеся слева сдвигаются вправо на 1 позицию до тех пор,
    // пока не будет перемещен элемент, который больше элемента с позицией 1.
    // Последнее перемещение открывает свободное место для помеченного элемента. Туда и вставляется помеченный элемент.
    // Маркер перемещается на элемент 2. Размер частично отсортированной подгруппы увеличивается на один элемент,
    // а неупорядоченная подгруппа становится на одного игрока меньше. Процесс повторяется до тех пор, пока все
    // неупорядоченные элементы не будут вставлены в соответствующие позиции частично отсортированной подгруппы.

    // Инвариант - в конце каждого прохода, непосредственно после вставки элемента из temp, элементы данных с индексами,
    // меньшими outer, являются частично отсортированными.

    // Работает примерно вдвое быстрее пузырьковой сортировки, а в обычных ситуациях немного быстрее сортировки
    // методом выбора. Часто используется в качестве завершающей стадии более сложных алгоритмов, например быстрой
    // сортировки. Если данные упорядочены, то условие цикла while никогда не бывает истинным; следовательно, оно
    // вырождается в простую команду во внешнем цикле, выполняемую N - 1 раз. В этом случае алгоритм выполняется за
    // время O(N). Но если данные изначально отсортированы в обратном порядке, алгоритму придется выполнить все
    // возможные сравнения и перемещения, и тогда сортировка методом вставки выполняется не быстрее пузырьковой
    // сортировки.

    // Количество сравнений - N x (N - 1) / 2
    // Количество копирований примерно совпадает с количеством сравнений. Однако копирование занимает меньше времени,
    // чем перестановка, поэтому этот алгоритм вдвое быстрее чем пузырьковая сортировка и быстрее чем
    // сортировка методом выбора.
    // Сложность - O(N^2)
    public static <T> void insertionSort(T[] array, Comparator<T> comparator) {
        for(int outer = 1; outer < array.length; outer++) {  // outer - маркер, разделяющий частично отсортированную подгруппу
            int minIndex = outer;
            T temp = array[minIndex];
            while (minIndex > 0 && comparator.compare(array[minIndex - 1], temp) > 0) {
                array[minIndex] = array[minIndex - 1];
                minIndex--;
            }
            array[minIndex] = temp;
        }
    }

}
